/* ggit-1.0.vapi generated by vapigen-0.36, do not modify. */

[CCode (cprefix = "Ggit", gir_namespace = "Ggit", gir_version = "1.0", lower_case_cprefix = "ggit_")]
namespace Ggit {
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_annotated_commit_ref", type_id = "ggit_annotated_commit_get_type ()", unref_function = "ggit_annotated_commit_unref")]
    [Compact]
    public class AnnotatedCommit {
        public Ggit.OId? get_id ();
        public unowned Ggit.AnnotatedCommit? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_blame_get_type ()")]
    public class Blame : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Blame ();
        public Ggit.Blame? from_buffer ([CCode (array_length_cname = "buffer_length", array_length_pos = 1.1, array_length_type = "gsize")] uint8[] buffer) throws GLib.Error;
        public static Ggit.BlameFlags get_flags (Ggit.BlameOptions blame_options);
        public Ggit.BlameHunk get_hunk_by_index (uint32 idx);
        public Ggit.BlameHunk get_hunk_by_line (uint32 line);
        public uint32 get_hunk_count ();
        public static void set_flags (Ggit.BlameOptions blame_options, Ggit.BlameFlags flags);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_blame_hunk_ref", type_id = "ggit_blame_hunk_get_type ()", unref_function = "ggit_blame_hunk_unref")]
    [Compact]
    public class BlameHunk {
        public unowned Ggit.OId? get_final_commit_id ();
        public unowned Ggit.Signature? get_final_signature ();
        public uint16 get_final_start_line_number ();
        public uint16 get_lines_in_hunk ();
        public unowned Ggit.OId? get_orig_commit_id ();
        public unowned string? get_orig_path ();
        public unowned Ggit.Signature? get_orig_signature ();
        public uint16 get_orig_start_line_number ();
        public bool is_boundary ();
        public unowned Ggit.BlameHunk? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_blame_options_get_type ()")]
    [Compact]
    public class BlameOptions {
        [CCode (has_construct_function = false)]
        public BlameOptions ();
        public Ggit.BlameOptions? copy ();
        public void free ();
        public uint32 get_maximum_line ();
        public uint32 get_minimum_line ();
        public uint16 get_minimum_match_characters ();
        public Ggit.OId? get_newest_commit ();
        public Ggit.OId? get_oldest_commit ();
        public void set_maximum_line (uint32 line);
        public void set_minimum_line (uint32 line);
        public void set_minimum_match_characters (uint16 characters);
        public void set_newest_commit (Ggit.OId? oid);
        public void set_oldest_commit (Ggit.OId? oid);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_blob_get_type ()")]
    public class Blob : Ggit.Object {
        [CCode (has_construct_function = false)]
        protected Blob ();
        [CCode (array_length_pos = 0.1, array_length_type = "gsize")]
        public unowned uint8[]? get_raw_content ();
        public bool is_binary ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_blob_output_stream_get_type ()")]
    public class BlobOutputStream : GLib.OutputStream {
        [CCode (has_construct_function = false)]
        protected BlobOutputStream ();
        public Ggit.OId? get_id () throws GLib.Error;
        public Ggit.Repository repository { construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_branch_get_type ()")]
    public class Branch : Ggit.Ref {
        [CCode (has_construct_function = false)]
        protected Branch ();
        public void @delete () throws GLib.Error;
        public unowned string? get_name () throws GLib.Error;
        public Ggit.Ref? get_upstream () throws GLib.Error;
        public bool is_head () throws GLib.Error;
        public Ggit.Branch? move (string new_branch_name, Ggit.CreateFlags flags) throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_branch_enumerator_ref", type_id = "ggit_branch_enumerator_get_type ()", unref_function = "ggit_branch_enumerator_unref")]
    [Compact]
    public class BranchEnumerator {
        public Ggit.Ref? @get ();
        public unowned Ggit.BranchEnumerator? iterator ();
        public bool next ();
        public Ggit.BranchEnumerator? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_checkout_options_get_type ()")]
    public class CheckoutOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public CheckoutOptions ();
        public unowned string? get_ancestor_label ();
        public unowned Ggit.Tree? get_baseline ();
        public uint get_dir_mode ();
        public bool get_disable_filters ();
        public uint get_file_mode ();
        public int get_file_open_flags ();
        public Ggit.CheckoutNotifyFlags get_notify_flags ();
        public unowned string? get_our_label ();
        [CCode (array_length = false, array_null_terminated = true)]
        public unowned string[]? get_paths ();
        public Ggit.CheckoutStrategy get_strategy ();
        public unowned string? get_target_directory ();
        public unowned string? get_their_label ();
        [NoWrapper]
        public virtual int notify (Ggit.CheckoutNotifyFlags why, string path, Ggit.DiffFile baseline, Ggit.DiffFile target, Ggit.DiffFile workdir);
        [NoWrapper]
        public virtual void progress (string path, size_t completed_steps, size_t total_steps);
        public void set_ancestor_label (string? label);
        public void set_baseline (Ggit.Tree? tree);
        public void set_dir_mode (uint dir_mode);
        public void set_disable_filters (bool disable);
        public void set_file_mode (uint file_mode);
        public void set_file_open_flags (int flags);
        public void set_notify_flags (Ggit.CheckoutNotifyFlags flags);
        public void set_our_label (string? label);
        public void set_paths ([CCode (array_length = false, array_null_terminated = true)] string[]? paths);
        public void set_strategy (Ggit.CheckoutStrategy strategy);
        public void set_target_directory (string? directory);
        public void set_their_label (string? label);
        public string ancestor_label { get; set; }
        public Ggit.Tree baseline { get; set; }
        public uint dir_mode { get; set; }
        public bool disable_filters { get; set; }
        public uint file_mode { get; set; }
        public int file_open_flags { get; set; }
        public Ggit.CheckoutNotifyFlags notify_flags { get; set; }
        public string our_label { get; set; }
        public Ggit.CheckoutStrategy strategy { get; set; }
        public string target_directory { get; set; }
        public string their_label { get; set; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_cherry_pick_options_get_type ()")]
    public class CherryPickOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public CherryPickOptions ();
        public unowned Ggit.CheckoutOptions get_checkout_options ();
        public uint get_mainline ();
        public Ggit.MergeOptions get_merge_options ();
        public void set_checkout_options (Ggit.CheckoutOptions? checkout_options);
        public void set_mainline (uint mainline);
        public void set_merge_options (Ggit.MergeOptions? merge_options);
        public Ggit.CheckoutOptions checkout_options { get; set; }
        public uint mainline { get; set; }
        public Ggit.MergeOptions merge_options { owned get; set; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_clone_options_get_type ()")]
    public class CloneOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public CloneOptions ();
        [NoWrapper]
        public virtual Ggit.Remote? create_remote (Ggit.Repository repository, string name, string url) throws GLib.Error;
        [NoWrapper]
        public virtual Ggit.Repository? create_repository (string path, bool is_bare) throws GLib.Error;
        public unowned string get_checkout_branch ();
        public unowned Ggit.FetchOptions get_fetch_options ();
        public bool get_is_bare ();
        public Ggit.CloneLocal get_local ();
        public void set_checkout_branch (string? checkout_branch);
        public void set_fetch_options (Ggit.FetchOptions? fetch_options);
        public void set_is_bare (bool bare);
        public void set_local (Ggit.CloneLocal local);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_commit_get_type ()")]
    public class Commit : Ggit.Object {
        [CCode (has_construct_function = false)]
        protected Commit ();
        public Ggit.OId? amend (string? update_ref, Ggit.Signature author, Ggit.Signature committer, string? message_encoding, string message, Ggit.Tree tree) throws GLib.Error;
        public Ggit.Signature? get_author ();
        public Ggit.Signature? get_committer ();
        public unowned string? get_message ();
        public unowned string? get_message_encoding ();
        public Ggit.Commit? get_nth_ancestor (uint n) throws GLib.Error;
        public Ggit.CommitParents? get_parents ();
        public unowned string? get_subject ();
        public Ggit.Tree? get_tree ();
        public Ggit.OId? get_tree_id ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_commit_parents_get_type ()")]
    public class CommitParents : GLib.Object {
        [CCode (has_construct_function = false)]
        public CommitParents (Ggit.Commit commit);
        public Ggit.Commit? @get (uint idx);
        public Ggit.OId? get_id (uint idx);
        public uint get_size ();
        [NoAccessorMethod]
        public Ggit.Commit commit { owned get; construct; }
        public uint size { get; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_config_get_type ()")]
    public class Config : Ggit.Native {
        [CCode (has_construct_function = false)]
        public Config ();
        public void add_file (GLib.File file, Ggit.ConfigLevel level, bool force) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Config.@default () throws GLib.Error;
        public bool delete_entry (string name) throws GLib.Error;
        public static GLib.File find_global ();
        public static GLib.File find_system ();
        public bool @foreach (Ggit.ConfigCallback callback) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Config.from_file (GLib.File file) throws GLib.Error;
        public bool get_bool (string name) throws GLib.Error;
        public Ggit.ConfigEntry get_entry (string name) throws GLib.Error;
        public int32 get_int32 (string name) throws GLib.Error;
        public int64 get_int64 (string name) throws GLib.Error;
        public unowned string? get_string (string name) throws GLib.Error;
        public string? match (GLib.Regex regex, out GLib.MatchInfo match_info) throws GLib.Error;
        public bool match_foreach (GLib.Regex regex, Ggit.ConfigMatchCallback callback) throws GLib.Error;
        public Ggit.Config open_level (Ggit.ConfigLevel level) throws GLib.Error;
        public bool set_bool (string name, bool value) throws GLib.Error;
        public bool set_int32 (string name, int32 value) throws GLib.Error;
        public bool set_int64 (string name, int64 value) throws GLib.Error;
        public bool set_string (string name, string value) throws GLib.Error;
        public Ggit.Config snapshot () throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_config_entry_ref", type_id = "ggit_config_entry_get_type ()", unref_function = "ggit_config_entry_unref")]
    [Compact]
    public class ConfigEntry {
        public Ggit.ConfigLevel get_level ();
        public unowned string? get_name ();
        public unowned string? get_value ();
        public unowned Ggit.ConfigEntry? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_cred_get_type ()")]
    public class Cred : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Cred ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_cred_plaintext_get_type ()")]
    public class CredPlaintext : Ggit.Cred, GLib.Initable {
        [CCode (has_construct_function = false)]
        public CredPlaintext (string username, string password) throws GLib.Error;
        public unowned string get_password ();
        public unowned string get_username ();
        public string password { get; construct; }
        public string username { get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_cred_ssh_interactive_get_type ()")]
    public class CredSshInteractive : Ggit.Cred, GLib.Initable {
        [CCode (has_construct_function = false)]
        public CredSshInteractive (string username) throws GLib.Error;
        public unowned string get_username ();
        [NoWrapper]
        public virtual void prompt ([CCode (array_length_cname = "num_prompts", array_length_pos = 1.1, array_length_type = "gsize")] Ggit.CredSshInteractivePrompt[] prompts);
        public string username { get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_cred_ssh_interactive_prompt_ref", type_id = "ggit_cred_ssh_interactive_prompt_get_type ()", unref_function = "ggit_cred_ssh_interactive_prompt_unref")]
    [Compact]
    public class CredSshInteractivePrompt {
        [CCode (has_construct_function = false)]
        public CredSshInteractivePrompt (string name, string instruction, string text, bool is_masked);
        public unowned string get_instruction ();
        public unowned string get_name ();
        public unowned string get_response ();
        public unowned string get_text ();
        public bool is_masked ();
        public Ggit.CredSshInteractivePrompt @ref ();
        public void set_response (string response);
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_cred_ssh_key_from_agent_get_type ()")]
    public class CredSshKeyFromAgent : Ggit.Cred, GLib.Initable {
        [CCode (has_construct_function = false)]
        public CredSshKeyFromAgent (string username) throws GLib.Error;
        public unowned string? get_username ();
        public string username { get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_diff_get_type ()")]
    public class Diff : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Diff ();
        public static void blob_to_buffer (Ggit.Blob? old_blob, string? old_as_path, [CCode (array_length_cname = "buffer_len", array_length_pos = 3.5, array_length_type = "gssize")] uint8[]? buffer, string? buffer_as_path, Ggit.DiffOptions? diff_options, [CCode (delegate_target_pos = 9.1)] Ggit.DiffFileCallback? file_cb, [CCode (delegate_target_pos = 9.1)] Ggit.DiffBinaryCallback? binary_cb, [CCode (delegate_target_pos = 9.1)] Ggit.DiffHunkCallback? hunk_cb, Ggit.DiffLineCallback? line_cb) throws GLib.Error;
        public static void blobs (Ggit.Blob? old_blob, string? old_as_path, Ggit.Blob? new_blob, string? new_as_path, Ggit.DiffOptions? diff_options, [CCode (delegate_target_pos = 9.1)] Ggit.DiffFileCallback? file_cb, [CCode (delegate_target_pos = 9.1)] Ggit.DiffBinaryCallback? binary_cb, [CCode (delegate_target_pos = 9.1)] Ggit.DiffHunkCallback? hunk_cb, Ggit.DiffLineCallback? line_cb) throws GLib.Error;
        public bool find_similar (Ggit.DiffFindOptions? options) throws GLib.Error;
        public void @foreach ([CCode (delegate_target_pos = 4.1)] Ggit.DiffFileCallback? file_cb, [CCode (delegate_target_pos = 4.1)] Ggit.DiffBinaryCallback? binary_cb, [CCode (delegate_target_pos = 4.1)] Ggit.DiffHunkCallback? hunk_cb, Ggit.DiffLineCallback? line_cb) throws GLib.Error;
        public string? format_email (Ggit.DiffFormatEmailOptions options) throws GLib.Error;
        public Ggit.DiffDelta? get_delta (size_t index);
        public size_t get_num_deltas ();
        [CCode (has_construct_function = false)]
        public Diff.index_to_workdir (Ggit.Repository repository, Ggit.Index? index, Ggit.DiffOptions? diff_options) throws GLib.Error;
        public void merge (Ggit.Diff from) throws GLib.Error;
        public void print (Ggit.DiffFormatType type, Ggit.DiffLineCallback print_cb) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Diff.tree_to_index (Ggit.Repository repository, Ggit.Tree? old_tree, Ggit.Index? index, Ggit.DiffOptions? diff_options) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Diff.tree_to_tree (Ggit.Repository repository, Ggit.Tree? old_tree, Ggit.Tree? new_tree, Ggit.DiffOptions? diff_options) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Diff.tree_to_workdir (Ggit.Repository repository, Ggit.Tree? old_tree, Ggit.DiffOptions? diff_options) throws GLib.Error;
        [NoAccessorMethod]
        public Ggit.Repository repository { owned get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_binary_ref", type_id = "ggit_diff_binary_get_type ()", unref_function = "ggit_diff_binary_unref")]
    [Compact]
    public class DiffBinary {
        public unowned Ggit.DiffBinaryFile? get_new_file ();
        public unowned Ggit.DiffBinaryFile? get_old_file ();
        public unowned Ggit.DiffBinary? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_binary_file_ref", type_id = "ggit_diff_binary_file_get_type ()", unref_function = "ggit_diff_binary_file_unref")]
    [Compact]
    public class DiffBinaryFile {
        public Ggit.DiffBinaryType get_binary_type ();
        public uint8 get_data (size_t? size);
        public size_t get_inflated_size ();
        public Ggit.DiffBinaryFile @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_delta_ref", type_id = "ggit_diff_delta_get_type ()", unref_function = "ggit_diff_delta_unref")]
    [Compact]
    public class DiffDelta {
        public Ggit.DiffFlag get_flags ();
        public unowned Ggit.DiffFile? get_new_file ();
        public unowned Ggit.DiffFile? get_old_file ();
        public uint get_similarity ();
        public Ggit.DeltaType get_status ();
        public unowned Ggit.DiffDelta? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_file_ref", type_id = "ggit_diff_file_get_type ()", unref_function = "ggit_diff_file_unref")]
    [Compact]
    public class DiffFile {
        public Ggit.DiffFlag get_flags ();
        public uint16 get_mode ();
        public unowned Ggit.OId? get_oid ();
        public unowned string? get_path ();
        public int64 get_size ();
        public unowned Ggit.DiffFile? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_diff_find_options_get_type ()")]
    public class DiffFindOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public DiffFindOptions ();
        public uint get_copy_threshold ();
        public Ggit.DiffFindFlags get_flags ();
        public unowned Ggit.DiffSimilarityMetric? get_metric ();
        public uint get_rename_from_rewrite_threshold ();
        public size_t get_rename_limit ();
        public uint get_rename_threshold ();
        public void set_copy_threshold (uint threshold);
        public void set_flags (Ggit.DiffFindFlags flags);
        public void set_metric (Ggit.DiffSimilarityMetric metric);
        public void set_rename_from_rewrite_threshold (uint threshold);
        public void set_rename_limit (size_t limit);
        public void set_rename_threshold (uint threshold);
        public uint copy_threshold { get; set; }
        public Ggit.DiffFindFlags flags { get; set; }
        public Ggit.DiffSimilarityMetric metric { get; set; }
        public uint rename_from_rewrite_threshold { get; set; }
        public uint rename_limit { get; set; }
        public uint rename_threshold { get; set; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_diff_format_email_options_get_type ()")]
    public class DiffFormatEmailOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public DiffFormatEmailOptions ();
        public unowned Ggit.Signature? get_author ();
        public Ggit.DiffFormatEmailFlags get_flags ();
        public unowned Ggit.OId? get_id ();
        public size_t get_patch_number ();
        public unowned string? get_summary ();
        public size_t get_total_patches ();
        public void set_author (Ggit.Signature? author);
        public void set_flags (Ggit.DiffFormatEmailFlags flags);
        public void set_id (Ggit.OId? id);
        public void set_patch_number (size_t number);
        public void set_summary (string? summary);
        public void set_total_patches (size_t patches);
        public Ggit.Signature author { get; set; }
        public Ggit.DiffFormatEmailFlags flags { get; set; }
        public Ggit.OId id { get; set; }
        public uint64 patch_number { get; set; }
        public string summary { get; set; }
        public uint64 total_patches { get; set; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_hunk_ref", type_id = "ggit_diff_hunk_get_type ()", unref_function = "ggit_diff_hunk_unref")]
    [Compact]
    public class DiffHunk {
        public unowned string get_header ();
        public int get_new_lines ();
        public int get_new_start ();
        public int get_old_lines ();
        public int get_old_start ();
        public unowned Ggit.DiffHunk? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_diff_line_ref", type_id = "ggit_diff_line_get_type ()", unref_function = "ggit_diff_line_unref")]
    [Compact]
    public class DiffLine {
        [CCode (array_length_pos = 0.1, array_length_type = "gsize")]
        public unowned uint8[] get_content ();
        public int64 get_content_offset ();
        public int get_new_lineno ();
        public int get_old_lineno ();
        public Ggit.DiffLineType get_origin ();
        public unowned string? get_text ();
        public unowned Ggit.DiffLine? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_diff_options_get_type ()")]
    public class DiffOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public DiffOptions ();
        public Ggit.DiffOption get_flags ();
        public int get_n_context_lines ();
        public int get_n_interhunk_lines ();
        public unowned string? get_new_prefix ();
        public string? get_old_prefix ();
        [CCode (array_length = false, array_null_terminated = true)]
        public unowned string[]? get_pathspec ();
        public void set_flags (Ggit.DiffOption flags);
        public void set_n_context_lines (int n);
        public void set_n_interhunk_lines (int n);
        public void set_new_prefix (string prefix);
        public void set_old_prefix (string prefix);
        public void set_pathspec ([CCode (array_length = false, array_null_terminated = true)] string[]? pathspec);
        public Ggit.DiffOption flags { get; set construct; }
        public int n_context_lines { get; set construct; }
        public int n_interhunk_lines { get; set construct; }
        public string new_prefix { get; set construct; }
        public string old_prefix { owned get; set construct; }
        [CCode (array_length = false, array_null_terminated = true)]
        public string[] pathspec { get; set construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_diff_similarity_metric_get_type ()")]
    [Compact]
    public class DiffSimilarityMetric {
        [CCode (has_construct_function = false)]
        public DiffSimilarityMetric (Ggit.DiffSimilarityMetricFileSignatureCallback file_signature, Ggit.DiffSimilarityMetricBufferSignatureCallback buffer_signature, Ggit.DiffSimilarityMetricFreeSignatureCallback free_signature, Ggit.DiffSimilarityMetricSimilarityCallback similarity);
        public Ggit.DiffSimilarityMetric? copy ();
        public void free ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_fetch_options_get_type ()")]
    [Compact]
    public class FetchOptions {
        [CCode (has_construct_function = false)]
        public FetchOptions ();
        public Ggit.FetchOptions? copy ();
        public void free ();
        public Ggit.RemoteDownloadTagsType get_download_tags ();
        public unowned Ggit.RemoteCallbacks? get_remote_callbacks ();
        public void set_download_tags (Ggit.RemoteDownloadTagsType download_tags);
        public void set_remote_callbacks (Ggit.RemoteCallbacks? callbacks);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_index_get_type ()")]
    public class Index : Ggit.Native, GLib.Initable {
        [CCode (has_construct_function = false)]
        protected Index ();
        public bool add (Ggit.IndexEntry entry) throws GLib.Error;
        public bool add_file (GLib.File file) throws GLib.Error;
        public bool add_path (string path) throws GLib.Error;
        public Ggit.IndexEntries? get_entries ();
        public Ggit.IndexEntriesResolveUndo? get_entries_resolve_undo ();
        public Ggit.Repository? get_owner ();
        public bool has_conflicts ();
        public static Ggit.Index? open (GLib.File file) throws GLib.Error;
        public bool read (bool force) throws GLib.Error;
        public bool remove (GLib.File file, int stage) throws GLib.Error;
        public bool write () throws GLib.Error;
        public Ggit.OId? write_tree () throws GLib.Error;
        public Ggit.OId? write_tree_to (Ggit.Repository repository) throws GLib.Error;
        [NoAccessorMethod]
        public GLib.File file { owned get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_index_entries_ref", type_id = "ggit_index_entries_get_type ()", unref_function = "ggit_index_entries_unref")]
    [Compact]
    public class IndexEntries {
        public Ggit.IndexEntry? get_by_index (size_t idx);
        public Ggit.IndexEntry? get_by_path (GLib.File file, int stage);
        public unowned Ggit.IndexEntries? @ref ();
        public uint size ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_index_entries_resolve_undo_ref", type_id = "ggit_index_entries_resolve_undo_get_type ()", unref_function = "ggit_index_entries_resolve_undo_unref")]
    [Compact]
    public class IndexEntriesResolveUndo {
        public Ggit.IndexEntryResolveUndo? @get (uint idx);
        public Ggit.IndexEntryResolveUndo? get_by_file (GLib.File file);
        public unowned Ggit.IndexEntriesResolveUndo? @ref ();
        public uint size ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_index_entry_ref", type_id = "ggit_index_entry_get_type ()", unref_function = "ggit_index_entry_unref")]
    [Compact]
    public class IndexEntry {
        public uint get_dev ();
        public int64 get_file_size ();
        public uint get_flags ();
        public uint get_flags_extended ();
        public uint get_gid ();
        public Ggit.OId? get_id ();
        public uint get_ino ();
        public uint get_mode ();
        public unowned string get_path ();
        public uint get_uid ();
        public bool is_conflict ();
        public unowned Ggit.IndexEntry? @ref ();
        public void set_commit (Ggit.Commit commit);
        public void set_dev (uint dev);
        public void set_file_size (int64 file_size);
        public void set_flags (uint flags);
        public void set_flags_extended (uint flags_extended);
        public void set_gid (uint gid);
        public void set_id (Ggit.OId? id);
        public void set_ino (uint ino);
        public void set_mode (uint mode);
        public void set_path (string? path);
        public void set_uid (uint uid);
        public bool stat (GLib.File file) throws GLib.Error;
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_index_entry_resolve_undo_ref", type_id = "ggit_index_entry_resolve_undo_get_type ()", unref_function = "ggit_index_entry_resolve_undo_unref")]
    [Compact]
    public class IndexEntryResolveUndo {
        public GLib.File? get_file ();
        public Ggit.OId? get_id (int stage);
        public uint get_mode (int stage);
        public unowned Ggit.IndexEntryResolveUndo? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_merge_options_get_type ()")]
    [Compact]
    public class MergeOptions {
        [CCode (has_construct_function = false)]
        public MergeOptions ();
        public Ggit.MergeOptions? copy ();
        public void free ();
        public Ggit.MergeFileFavor get_file_favor ();
        public Ggit.MergeFileFlags get_file_flags ();
        public Ggit.MergeFlags get_flags ();
        public uint get_rename_threshold ();
        public unowned Ggit.DiffSimilarityMetric? get_similarity_metric ();
        public uint get_target_limit ();
        public void set_file_favor (Ggit.MergeFileFavor file_favor);
        public void set_file_flags (Ggit.MergeFileFlags file_flags);
        public void set_flags (Ggit.MergeFlags flags);
        public void set_rename_threshold (uint rename_threshold);
        public void set_similarity_metric (Ggit.DiffSimilarityMetric metric);
        public void set_target_limit (uint target_limit);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_native_get_type ()")]
    public abstract class Native : Ggit.ObjectFactoryBase {
        [CCode (has_construct_function = false)]
        protected Native ();
        public void* native { construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_note_ref", type_id = "ggit_note_get_type ()", unref_function = "ggit_note_unref")]
    [Compact]
    public class Note {
        public unowned Ggit.OId? get_id ();
        public unowned string? get_message ();
        public unowned Ggit.Note? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_oid_get_type ()")]
    [Compact]
    public class OId {
        public int compare (Ggit.OId b);
        public Ggit.OId? copy ();
        public bool equal (Ggit.OId b);
        public void free ();
        [CCode (has_construct_function = false)]
        public OId.from_raw (uint8 raw);
        [CCode (has_construct_function = false)]
        public OId.from_string (string str);
        public bool has_prefix (string prefix);
        public uint hash ();
        public bool is_zero ();
        public string? to_string ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_object_get_type ()")]
    public abstract class Object : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Object ();
        public Ggit.OId? get_id ();
        public Ggit.Repository? get_owner ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_object_factory_get_type ()")]
    public class ObjectFactory : GLib.Object {
        [CCode (has_construct_function = false)]
        protected ObjectFactory ();
        public GLib.Object? @construct (GLib.ObjectClass parent_class, GLib.Type basetype, [CCode (array_length_cname = "n_construct_properties", array_length_pos = 2.5, array_length_type = "guint")] GLib.ObjectConstructParam[] construct_properties);
        public static unowned Ggit.ObjectFactory get_default ();
        public void register (GLib.Type basetype, GLib.Type subtype);
        public void unregister (GLib.Type basetype, GLib.Type subtype);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_object_factory_base_get_type ()")]
    public abstract class ObjectFactoryBase : GLib.Object {
        [CCode (has_construct_function = false)]
        protected ObjectFactoryBase ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_patch_ref", type_id = "ggit_patch_get_type ()", unref_function = "ggit_patch_unref")]
    [Compact]
    public class Patch {
        [CCode (has_construct_function = false)]
        public Patch.from_blobs (Ggit.Blob? old_blob, string? old_as_path, Ggit.Blob? new_blob, string? new_as_path, Ggit.DiffOptions? diff_options) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Patch.from_diff (Ggit.Diff diff, size_t idx) throws GLib.Error;
        public Ggit.DiffDelta? get_delta ();
        public Ggit.DiffHunk? get_hunk (size_t idx) throws GLib.Error;
        public bool get_line_stats (out size_t total_context, out size_t total_additions, out size_t total_deletions) throws GLib.Error;
        public size_t get_num_hunks ();
        public int get_num_lines_in_hunk (size_t hunk);
        public unowned Ggit.Patch? @ref ();
        public bool to_stream (GLib.OutputStream stream) throws GLib.Error;
        public string? to_string () throws GLib.Error;
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_proxy_options_get_type ()")]
    public class ProxyOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public ProxyOptions ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_push_options_get_type ()")]
    public class PushOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public PushOptions ();
        public int get_parallelism ();
        public void set_parallelism (int parallelism);
        public int parallelism { get; set construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_rebase_get_type ()")]
    public class Rebase : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Rebase ();
        public void abort () throws GLib.Error;
        public Ggit.OId? commit (Ggit.Signature? author, Ggit.Signature committer, string? message) throws GLib.Error;
        public void finish (Ggit.Signature? signature) throws GLib.Error;
        public Ggit.RebaseOperation? get_operation_by_index (size_t idx);
        public size_t get_operation_entry_count ();
        public size_t get_operation_index ();
        public Ggit.RebaseOperation? next () throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_rebase_operation_ref", type_id = "ggit_rebase_operation_get_type ()", unref_function = "ggit_rebase_operation_unref")]
    [Compact]
    public class RebaseOperation {
        public unowned string? get_exec ();
        public Ggit.OId? get_id ();
        public Ggit.RebaseOperationType get_operation_type ();
        public unowned Ggit.RebaseOperation? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_rebase_options_get_type ()")]
    [Compact]
    public class RebaseOptions {
        [CCode (has_construct_function = false)]
        public RebaseOptions ();
        public Ggit.RebaseOptions? copy ();
        public void free ();
        public unowned Ggit.CheckoutOptions? get_checkout_options ();
        public bool get_quiet ();
        public unowned string? get_rewrite_notes_ref ();
        public void set_checkout_options (Ggit.CheckoutOptions checkout_options);
        public void set_quiet (bool quiet);
        public void set_rewrite_notes_ref (string rewrite_notes_ref);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_ref_get_type ()")]
    public class Ref : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected Ref ();
        public void @delete () throws GLib.Error;
        public void delete_log () throws GLib.Error;
        public Ggit.Reflog? get_log () throws GLib.Error;
        public unowned string? get_name ();
        public Ggit.Repository? get_owner ();
        public Ggit.RefType get_reference_type ();
        public unowned string? get_shorthand ();
        public unowned string? get_symbolic_target ();
        public Ggit.OId? get_target ();
        public bool has_log ();
        public bool is_branch ();
        public bool is_note ();
        public bool is_remote ();
        public bool is_tag ();
        public static bool is_valid_name (string name);
        public Ggit.Object? lookup () throws GLib.Error;
        public Ggit.Ref? rename (string new_name, bool force, string log_message) throws GLib.Error;
        public Ggit.Ref? resolve () throws GLib.Error;
        public Ggit.Ref? set_symbolic_target (string target, string log_message) throws GLib.Error;
        public Ggit.Ref? set_target (Ggit.OId oid, string log_message) throws GLib.Error;
        public unowned string? to_string ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_ref_spec_ref", type_id = "ggit_ref_spec_get_type ()", unref_function = "ggit_ref_spec_unref")]
    [Compact]
    public class RefSpec {
        public unowned string? get_destination ();
        public unowned string? get_source ();
        public bool is_forced ();
        public unowned Ggit.RefSpec? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_reflog_ref", type_id = "ggit_reflog_get_type ()", unref_function = "ggit_reflog_unref")]
    [Compact]
    public class Reflog {
        public bool append (Ggit.OId oid, Ggit.Signature committer, string message) throws GLib.Error;
        public uint get_entry_count ();
        public Ggit.ReflogEntry? get_entry_from_index (uint idx);
        public unowned Ggit.Reflog? @ref ();
        public bool rename (string new_name) throws GLib.Error;
        public void unref ();
        public bool write () throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_reflog_entry_ref", type_id = "ggit_reflog_entry_get_type ()", unref_function = "ggit_reflog_entry_unref")]
    [Compact]
    public class ReflogEntry {
        public unowned Ggit.Signature? get_committer ();
        public unowned string? get_message ();
        public Ggit.OId? get_new_id ();
        public Ggit.OId? get_old_id ();
        public unowned Ggit.ReflogEntry? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_remote_get_type ()")]
    public class Remote : Ggit.Native {
        [CCode (has_construct_function = false)]
        public Remote (Ggit.Repository repository, string name, string url) throws GLib.Error;
        [CCode (has_construct_function = false)]
        public Remote.anonymous (Ggit.Repository repository, string url) throws GLib.Error;
        public void connect (Ggit.Direction direction, Ggit.RemoteCallbacks callbacks, Ggit.ProxyOptions? proxy_options, string? custom_headers) throws GLib.Error;
        public void disconnect ();
        public bool download ([CCode (array_length = false, array_null_terminated = true)] string[]? specs, Ggit.FetchOptions fetch_options) throws GLib.Error;
        public bool get_connected ();
        [CCode (array_length = false, array_null_terminated = true)]
        public string[]? get_fetch_specs () throws GLib.Error;
        public unowned string? get_name ();
        public Ggit.Repository? get_owner ();
        [CCode (array_length = false, array_null_terminated = true)]
        public string[]? get_push_specs () throws GLib.Error;
        public unowned string? get_url ();
        [CCode (array_length = false, array_null_terminated = true)]
        public Ggit.RemoteHead[]? list () throws GLib.Error;
        public bool update_tips (Ggit.RemoteCallbacks callbacks, bool update_fetch_head, Ggit.RemoteDownloadTagsType tags_type, string? message) throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_remote_callbacks_get_type ()")]
    public class RemoteCallbacks : GLib.Object {
        [CCode (has_construct_function = false)]
        protected RemoteCallbacks ();
        [NoWrapper]
        public virtual Ggit.Cred? credentials (string url, string? username_from_url, Ggit.Credtype allowed_types) throws GLib.Error;
        public virtual signal void completion (Ggit.RemoteCompletionType type);
        public virtual signal void progress (string message);
        public virtual signal void transfer_progress (Ggit.TransferProgress stats);
        public virtual signal void update_tips (string refname, Ggit.OId a, Ggit.OId b);
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_remote_head_ref", type_id = "ggit_remote_head_get_type ()", unref_function = "ggit_remote_head_unref")]
    [Compact]
    public class RemoteHead {
        public unowned Ggit.OId? get_local_oid ();
        public unowned string? get_name ();
        public unowned Ggit.OId? get_oid ();
        public bool is_local ();
        public Ggit.RemoteHead @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_repository_get_type ()")]
    public class Repository : Ggit.Native, GLib.Initable {
        [CCode (has_construct_function = false)]
        protected Repository ();
        public void add_remote_fetch (Ggit.Remote remote, string refspec) throws GLib.Error;
        public void add_remote_push (Ggit.Remote remote, string refspec) throws GLib.Error;
        public Ggit.Blame? blame_file (GLib.File file, Ggit.BlameOptions? blame_options) throws GLib.Error;
        public bool checkout_head (Ggit.CheckoutOptions? options) throws GLib.Error;
        public bool checkout_index (Ggit.Index? index, Ggit.CheckoutOptions? options) throws GLib.Error;
        public bool checkout_tree (Ggit.Object? tree, Ggit.CheckoutOptions? options) throws GLib.Error;
        public bool cherry_pick (Ggit.Commit commit, Ggit.CherryPickOptions options) throws GLib.Error;
        public Ggit.Index? cherry_pick_commit (Ggit.Commit commit, Ggit.Commit our_commit, uint mainline, Ggit.MergeOptions? merge_options) throws GLib.Error;
        public static Ggit.Repository? clone (string url, GLib.File location, Ggit.CloneOptions? options) throws GLib.Error;
        public Ggit.BlobOutputStream? create_blob ();
        public Ggit.OId? create_blob_from_buffer ([CCode (array_length_cname = "size", array_length_pos = 1.1, array_length_type = "gsize")] uint8[] buffer) throws GLib.Error;
        public Ggit.OId create_blob_from_file (GLib.File file) throws GLib.Error;
        public Ggit.OId? create_blob_from_path (string path) throws GLib.Error;
        public Ggit.Branch? create_branch (string branch_name, Ggit.Object target, Ggit.CreateFlags flags) throws GLib.Error;
        public Ggit.OId? create_commit (string? update_ref, Ggit.Signature author, Ggit.Signature committer, string? message_encoding, string message, Ggit.Tree tree, [CCode (array_length_cname = "parent_count", array_length_pos = 7.1)] Ggit.Commit[] parents) throws GLib.Error;
        public Ggit.OId? create_commit_from_ids (string? update_ref, Ggit.Signature author, Ggit.Signature committer, string? message_encoding, string message, Ggit.OId tree, [CCode (array_length_cname = "parent_count", array_length_pos = 7.1)] Ggit.OId[] parents) throws GLib.Error;
        public Ggit.IndexEntry? create_index_entry_for_file (GLib.File? file, Ggit.OId? id) throws GLib.Error;
        public Ggit.IndexEntry? create_index_entry_for_path (string? path, Ggit.OId? id) throws GLib.Error;
        public Ggit.OId? create_note (string? notes_ref, Ggit.Signature author, Ggit.Signature committer, Ggit.OId id, string note, bool force) throws GLib.Error;
        public Ggit.Ref? create_reference (string name, Ggit.OId oid, string log_message) throws GLib.Error;
        public Ggit.Remote? create_remote (string name, string url) throws GLib.Error;
        public Ggit.Ref? create_symbolic_reference (string name, string target, string log_message) throws GLib.Error;
        public Ggit.OId? create_tag (string tag_name, Ggit.Object target, Ggit.Signature tagger, string message, Ggit.CreateFlags flags) throws GLib.Error;
        public Ggit.OId? create_tag_annotation (string tag_name, Ggit.Object target, Ggit.Signature signature, string message) throws GLib.Error;
        public Ggit.OId? create_tag_from_buffer (string tag, Ggit.CreateFlags flags) throws GLib.Error;
        public Ggit.OId? create_tag_lightweight (string tag_name, Ggit.Object target, Ggit.CreateFlags flags) throws GLib.Error;
        public Ggit.TreeBuilder? create_tree_builder () throws GLib.Error;
        public Ggit.TreeBuilder? create_tree_builder_from_tree (Ggit.Tree tree) throws GLib.Error;
        public bool delete_tag (string name) throws GLib.Error;
        public static GLib.File? discover (GLib.File location) throws GLib.Error;
        public static GLib.File? discover_full (GLib.File location, bool across_fs, [CCode (array_length = false, array_null_terminated = true)] string[]? ceiling_dirs) throws GLib.Error;
        public void drop_stash (size_t index) throws GLib.Error;
        public Ggit.BranchEnumerator? enumerate_branches (Ggit.BranchType list_type) throws GLib.Error;
        public Ggit.StatusFlags file_status (GLib.File location) throws GLib.Error;
        public bool file_status_foreach (Ggit.StatusOptions? options, Ggit.StatusCallback callback) throws GLib.Error;
        public void get_ahead_behind (Ggit.OId local, Ggit.OId upstream, out size_t ahead, out size_t behind) throws GLib.Error;
        public unowned string? get_attribute (string path, string name, Ggit.AttributeCheckFlags flags) throws GLib.Error;
        public Ggit.Config? get_config () throws GLib.Error;
        public string? get_default_notes_ref () throws GLib.Error;
        public bool get_descendant_of (Ggit.OId commit, Ggit.OId ancestor) throws GLib.Error;
        public Ggit.Ref? get_head () throws GLib.Error;
        public Ggit.Index? get_index () throws GLib.Error;
        public GLib.File? get_location ();
        public Ggit.SubmoduleStatus get_submodule_status (string name, Ggit.SubmoduleIgnore ignore) throws GLib.Error;
        public GLib.File? get_workdir ();
        public static Ggit.Repository? init_repository (GLib.File location, bool is_bare) throws GLib.Error;
        public bool is_empty () throws GLib.Error;
        public bool is_head_detached () throws GLib.Error;
        public bool is_head_unborn () throws GLib.Error;
        [CCode (array_length = false, array_null_terminated = true)]
        public string[]? list_remotes () throws GLib.Error;
        [CCode (array_length = false, array_null_terminated = true)]
        public string[]? list_tags () throws GLib.Error;
        [CCode (array_length = false, array_null_terminated = true)]
        public string[]? list_tags_match (string? pattern) throws GLib.Error;
        public Ggit.Object? lookup (Ggit.OId oid, GLib.Type gtype) throws GLib.Error;
        public Ggit.Blob? lookup_blob (Ggit.OId oid) throws GLib.Error;
        public Ggit.Branch? lookup_branch (string branch_name, Ggit.BranchType branch_type) throws GLib.Error;
        public Ggit.Commit? lookup_commit (Ggit.OId oid) throws GLib.Error;
        public Ggit.Ref? lookup_reference (string name) throws GLib.Error;
        public Ggit.Ref? lookup_reference_dwim (string short_name) throws GLib.Error;
        public Ggit.Remote? lookup_remote (string name) throws GLib.Error;
        public Ggit.Submodule? lookup_submodule (string name) throws GLib.Error;
        public Ggit.Tag? lookup_tag (Ggit.OId oid) throws GLib.Error;
        public Ggit.Tree? lookup_tree (Ggit.OId oid) throws GLib.Error;
        public Ggit.Index? merge_commits (Ggit.Commit our_commit, Ggit.Commit their_commit, Ggit.MergeOptions merge_options) throws GLib.Error;
        public Ggit.Index? merge_trees (Ggit.Tree ancestor_tree, Ggit.Tree our_tree, Ggit.Tree their_tree, Ggit.MergeOptions merge_options) throws GLib.Error;
        public bool note_foreach (string? notes_ref, Ggit.NoteCallback callback) throws GLib.Error;
        public static Ggit.Repository? open (GLib.File location) throws GLib.Error;
        public bool path_is_ignored (string path) throws GLib.Error;
        public Ggit.Note? read_note (string? notes_ref, Ggit.OId id) throws GLib.Error;
        public Ggit.Rebase? rebase_init (Ggit.AnnotatedCommit? branch, Ggit.AnnotatedCommit? upstream, Ggit.AnnotatedCommit? onto, Ggit.RebaseOptions options) throws GLib.Error;
        public Ggit.Rebase? rebase_open (Ggit.RebaseOptions options) throws GLib.Error;
        public bool references_foreach (Ggit.ReferencesCallback callback) throws GLib.Error;
        public bool references_foreach_name (Ggit.ReferencesNameCallback callback) throws GLib.Error;
        public bool remove_note (string? notes_ref, Ggit.Signature author, Ggit.Signature committer, Ggit.OId id) throws GLib.Error;
        public void reset (Ggit.Object target, Ggit.ResetType reset_type, Ggit.CheckoutOptions checkout_options) throws GLib.Error;
        public void reset_default (Ggit.Object? target, [CCode (array_length = false, array_null_terminated = true)] string[] pathspecs) throws GLib.Error;
        public bool revert (Ggit.Commit commit, Ggit.RevertOptions options) throws GLib.Error;
        public Ggit.Object? revparse (string spec) throws GLib.Error;
        public Ggit.OId? save_stash (Ggit.Signature stasher, string message, Ggit.StashFlags flags) throws GLib.Error;
        public bool set_head (string ref_name) throws GLib.Error;
        public void set_submodule_fetch_recurse (string name, Ggit.SubmoduleRecurse fetch_recurse_submodules) throws GLib.Error;
        public void set_submodule_ignore (string name, Ggit.SubmoduleIgnore ignore) throws GLib.Error;
        public void set_submodule_update (string name, Ggit.SubmoduleUpdate update) throws GLib.Error;
        public void set_submodule_url (string name, string url) throws GLib.Error;
        public void set_workdir (GLib.File workdir, bool update_gitlink);
        public bool stash_foreach (Ggit.StashCallback callback) throws GLib.Error;
        public bool submodule_foreach (Ggit.SubmoduleCallback callback) throws GLib.Error;
        public bool tag_foreach (Ggit.TagCallback callback) throws GLib.Error;
        [NoAccessorMethod]
        public Ggit.CloneOptions clone_options { owned get; construct; }
        public Ggit.Ref head { owned get; }
        [NoAccessorMethod]
        public bool init { get; construct; }
        [NoAccessorMethod]
        public bool is_bare { get; construct; }
        public GLib.File location { owned get; construct; }
        [NoAccessorMethod]
        public string url { owned get; construct; }
        [NoAccessorMethod]
        public GLib.File workdir { owned get; set construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_revert_options_get_type ()")]
    [Compact]
    public class RevertOptions {
        [CCode (has_construct_function = false)]
        public RevertOptions (uint mainline, Ggit.MergeOptions? merge_options, Ggit.CheckoutOptions? checkout_options);
        public Ggit.RevertOptions? copy ();
        public void free ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_revision_walker_get_type ()")]
    public class RevisionWalker : Ggit.Native, GLib.Initable {
        [CCode (has_construct_function = false)]
        public RevisionWalker (Ggit.Repository repository) throws GLib.Error;
        public unowned Ggit.Repository? get_repository ();
        public void hide (Ggit.OId oid) throws GLib.Error;
        public void hide_glob (string item) throws GLib.Error;
        public void hide_head () throws GLib.Error;
        public void hide_ref (string item) throws GLib.Error;
        public Ggit.OId? next () throws GLib.Error;
        public void push (Ggit.OId oid) throws GLib.Error;
        public void push_glob (string item) throws GLib.Error;
        public void push_head () throws GLib.Error;
        public void push_range (string range) throws GLib.Error;
        public void push_ref (string item) throws GLib.Error;
        public void reset ();
        public void set_sort_mode (Ggit.SortMode sort_mode);
        [NoAccessorMethod]
        public Ggit.Repository repository { owned get; set construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_signature_get_type ()")]
    public class Signature : Ggit.Native {
        [CCode (has_construct_function = false)]
        public Signature (string name, string email, GLib.DateTime signature_time) throws GLib.Error;
        public Ggit.Signature? copy ();
        public unowned string? get_email ();
        public unowned string? get_name ();
        public GLib.DateTime? get_time ();
        public GLib.TimeZone? get_time_zone ();
        [CCode (has_construct_function = false)]
        public Signature.now (string name, string email) throws GLib.Error;
        [NoAccessorMethod]
        public string encoding { owned get; construct; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_status_options_get_type ()")]
    [Compact]
    public class StatusOptions {
        [CCode (has_construct_function = false)]
        public StatusOptions (Ggit.StatusOption options, Ggit.StatusShow show, [CCode (array_length = false, array_null_terminated = true)] string[]? pathspec);
        public Ggit.StatusOptions? copy ();
        public void free ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_submodule_ref", type_id = "ggit_submodule_get_type ()", unref_function = "ggit_submodule_unref")]
    [Compact]
    public class Submodule {
        public bool get_fetch_recurse ();
        public Ggit.OId get_head_id ();
        public Ggit.SubmoduleIgnore get_ignore ();
        public Ggit.OId? get_index_id ();
        public unowned string? get_name ();
        public Ggit.Repository? get_owner ();
        public unowned string? get_path ();
        public Ggit.SubmoduleUpdate get_update ();
        public unowned string? get_url ();
        public Ggit.OId? get_workdir_id ();
        public void init (bool overwrite) throws GLib.Error;
        public Ggit.Repository? open () throws GLib.Error;
        public unowned Ggit.Submodule? @ref ();
        public void reload (bool force) throws GLib.Error;
        public void sync () throws GLib.Error;
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_submodule_update_options_get_type ()")]
    public class SubmoduleUpdateOptions : GLib.Object {
        [CCode (has_construct_function = false)]
        public SubmoduleUpdateOptions ();
        public unowned Ggit.CheckoutOptions? get_checkout_options ();
        public Ggit.FetchOptions get_fetch_options ();
        public void set_checkout_options (Ggit.CheckoutOptions? checkout_options);
        public void set_fetch_options (Ggit.FetchOptions? fetch_options);
        public Ggit.CheckoutOptions checkout_options { get; set; }
        public Ggit.FetchOptions fetch_options { owned get; set; }
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_tag_get_type ()")]
    public class Tag : Ggit.Object {
        [CCode (has_construct_function = false)]
        protected Tag ();
        public unowned string? get_message ();
        public unowned string? get_name ();
        public Ggit.Signature? get_tagger ();
        public Ggit.Object? get_target () throws GLib.Error;
        public Ggit.OId? get_target_id ();
        public GLib.Type get_target_type ();
        public Ggit.Object? peel () throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "ggit_transfer_progress_get_type ()")]
    [Compact]
    public class TransferProgress {
        public Ggit.TransferProgress? copy ();
        public void free ();
        public uint get_indexed_objects ();
        public size_t get_received_bytes ();
        public uint get_received_objects ();
        public uint get_total_objects ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_tree_get_type ()")]
    public class Tree : Ggit.Object {
        [CCode (has_construct_function = false)]
        protected Tree ();
        public Ggit.TreeEntry? @get (uint i);
        public Ggit.TreeEntry? get_by_name (string name);
        public Ggit.TreeEntry? get_by_path (string path) throws GLib.Error;
        public Ggit.OId? get_id ();
        public uint size ();
        public void walk (Ggit.TreeWalkMode mode, Ggit.TreeWalkCallback callback) throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", type_id = "ggit_tree_builder_get_type ()")]
    public class TreeBuilder : Ggit.Native {
        [CCode (has_construct_function = false)]
        protected TreeBuilder ();
        public void clear ();
        public Ggit.TreeEntry? get_entry (string path);
        public Ggit.TreeEntry? insert (string filename, Ggit.OId oid, Ggit.FileMode file_mode) throws GLib.Error;
        public void remove (string path) throws GLib.Error;
        public Ggit.OId? write () throws GLib.Error;
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", ref_function = "ggit_tree_entry_ref", type_id = "ggit_tree_entry_get_type ()", unref_function = "ggit_tree_entry_unref")]
    [Compact]
    public class TreeEntry {
        public Ggit.FileMode get_file_mode ();
        public Ggit.OId? get_id ();
        public unowned string? get_name ();
        public GLib.Type get_object_type ();
        public unowned Ggit.TreeEntry? @ref ();
        public void unref ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_ATTRIBUTE_CHECK_", type_id = "ggit_attribute_check_flags_get_type ()")]
    [Flags]
    public enum AttributeCheckFlags {
        FILE_THEN_INDEX,
        INDEX_THEN_FILE,
        INDEX_ONLY,
        NO_SYSTEM
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_BLAME_", type_id = "ggit_blame_flags_get_type ()")]
    [Flags]
    public enum BlameFlags {
        NORMAL,
        TRACK_COPIES_SAME_FILE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_BRANCH_", type_id = "ggit_branch_type_get_type ()")]
    public enum BranchType {
        LOCAL,
        REMOTE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CHECKOUT_NOTIFY_", type_id = "ggit_checkout_notify_flags_get_type ()")]
    [Flags]
    public enum CheckoutNotifyFlags {
        NONE,
        CONFLICT,
        DIRTY,
        UPDATED,
        UNTRACKED,
        IGNORED,
        ALL
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CHECKOUT_", type_id = "ggit_checkout_strategy_get_type ()")]
    [Flags]
    public enum CheckoutStrategy {
        NONE,
        SAFE,
        FORCE,
        RECREATE_MISSING,
        ALLOW_CONFLICTS,
        REMOVE_UNTRACKED,
        REMOVE_IGNORED,
        UPDATE_ONLY,
        DONT_UPDATE_INDEX,
        NO_REFRESH,
        SKIP_UNMERGED,
        USE_OURS,
        USE_THEIRS,
        DISABLE_PATHSPEC_MATCH,
        SKIP_LOCKED_DIRECTORIES,
        DONT_OVERWRITE_IGNORED,
        CONFLICT_STYLE_MERGE,
        CONFLICT_STYLE_DIFF3,
        DONT_REMOVE_EXISTING,
        DONT_WRITE_INDEX,
        UPDATE_SUBMODULES,
        UPDATE_SUBMODULES_IF_CHANGED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CLONE_LOCAL_", type_id = "ggit_clone_local_get_type ()")]
    public enum CloneLocal {
        AUTO,
        LOCAL,
        NO_LOCAL,
        NO_LINKS
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CONFIG_LEVEL_", type_id = "ggit_config_level_get_type ()")]
    public enum ConfigLevel {
        PROGRAMDATA,
        SYSTEM,
        XDG,
        GLOBAL,
        LOCAL,
        APP,
        HIGHEST
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CREATE_", type_id = "ggit_create_flags_get_type ()")]
    [Flags]
    public enum CreateFlags {
        NONE,
        FORCE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_CREDTYPE_", type_id = "ggit_credtype_get_type ()")]
    [Flags]
    public enum Credtype {
        USERPASS_PLAINTEXT,
        SSH_KEY,
        SSH_CUSTOM,
        DEFAULT,
        SSH_INTERACTIVE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DELTA_", type_id = "ggit_delta_type_get_type ()")]
    public enum DeltaType {
        UNMODIFIED,
        ADDED,
        DELETED,
        MODIFIED,
        RENAMED,
        COPIED,
        IGNORED,
        UNTRACKED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_BINARY_", type_id = "ggit_diff_binary_type_get_type ()")]
    public enum DiffBinaryType {
        NONE,
        LITERAL,
        DELTA
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_", type_id = "ggit_diff_find_flags_get_type ()")]
    [Flags]
    public enum DiffFindFlags {
        FIND_BY_CONFIG,
        FIND_RENAMES,
        FIND_RENAMES_FROM_REWRITES,
        FIND_COPIES,
        FIND_COPIES_FROM_UNMODIFIED,
        FIND_REWRITES,
        BREAK_REWRITES,
        FIND_AND_BREAK_REWRITES,
        FIND_FOR_UNTRACKED,
        FIND_ALL,
        FIND_IGNORE_LEADING_WHITESPACE,
        FIND_IGNORE_WHITESPACE,
        FIND_DONT_IGNORE_WHITESPACE,
        FIND_EXACT_MATCH_ONLY,
        BREAK_REWRITES_FOR_RENAMES_ONLY,
        FIND_REMOVE_UNMODIFIED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_FLAG_", type_id = "ggit_diff_flag_get_type ()")]
    [Flags]
    public enum DiffFlag {
        BINARY,
        NOT_BINARY,
        VALID_ID
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_FORMAT_EMAIL_", type_id = "ggit_diff_format_email_flags_get_type ()")]
    [Flags]
    public enum DiffFormatEmailFlags {
        NONE,
        EXCLUDE_SUBJECT_PATCH_MARKER
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_FORMAT_", type_id = "ggit_diff_format_type_get_type ()")]
    public enum DiffFormatType {
        PATCH,
        PATCH_HEADER,
        RAW,
        NAME_ONLY,
        NAME_STATUS
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_LINE_", type_id = "ggit_diff_line_type_get_type ()")]
    public enum DiffLineType {
        CONTEXT,
        ADDITION,
        DELETION,
        CONTEXT_EOFNL,
        ADD_EOFNL,
        DEL_EOFNL,
        FILE_HDR,
        HUNK_HDR,
        BINARY
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIFF_", type_id = "ggit_diff_option_get_type ()")]
    [Flags]
    public enum DiffOption {
        NORMAL,
        REVERSE,
        INCLUDE_IGNORED,
        RECURSE_IGNORED_DIRS,
        INCLUDE_UNTRACKED,
        RECURSE_UNTRACKED_DIRS,
        INCLUDE_UNMODIFIED,
        INCLUDE_TYPECHANGE,
        INCLUDE_TYPECHANGE_TREES,
        IGNORE_FILE_MODE,
        IGNORE_SUBMODULES,
        IGNORE_CASE,
        DISABLE_PATHSPEC_MATCH,
        SKIP_BINARY_CHECK,
        ENABLE_FAST_UNTRACKED_DIRS,
        FORCE_TEXT,
        FORCE_BINARY,
        IGNORE_WHITESPACE,
        IGNORE_WHITESPACE_CHANGE,
        IGNORE_WHITESPACE_EOL,
        SHOW_UNTRACKED_CONTENT,
        SHOW_UNMODIFIED,
        PATIENCE,
        MINIMAL,
        SHOW_BINARY
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_DIRECTION_", type_id = "ggit_direction_get_type ()")]
    public enum Direction {
        FETCH,
        PUSH
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_FEATURE_", type_id = "ggit_feature_flags_get_type ()")]
    [Flags]
    public enum FeatureFlags {
        THREADS,
        HTTPS,
        SSH
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_FILE_MODE_", type_id = "ggit_file_mode_get_type ()")]
    public enum FileMode {
        UNREADABLE,
        TREE,
        BLOB,
        BLOB_EXECUTABLE,
        LINK,
        COMMIT
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_MERGE_FILE_FAVOR_", type_id = "ggit_merge_file_favor_get_type ()")]
    public enum MergeFileFavor {
        NORMAL,
        OURS,
        THEIRS,
        UNION
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_MERGE_FILE_", type_id = "ggit_merge_file_flags_get_type ()")]
    [Flags]
    public enum MergeFileFlags {
        DEFAULT,
        STYLE_MERGE,
        STYLE_DIFF3,
        SIMPLIFY_ALNUM,
        IGNORE_WHITESPACE,
        IGNORE_WHITESPACE_CHANGE,
        IGNORE_WHITESPACE_EOL,
        DIFF_PATIENCE,
        DIFF_MINIMAL
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_MERGE_", type_id = "ggit_merge_flags_get_type ()")]
    [Flags]
    public enum MergeFlags {
        FIND_RENAMES,
        FAIL_ON_CONFLICT,
        SKIP_REUC,
        NO_RECURSIVE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_PACKBUILDER_STAGE_", type_id = "ggit_packbuilder_stage_get_type ()")]
    public enum PackbuilderStage {
        ADDING_OBJECTS,
        DELTAFICATION
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_PROXY_", type_id = "ggit_proxy_type_get_type ()")]
    public enum ProxyType {
        NONE,
        AUTO,
        SPECIFIED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_REBASE_OPERATION_", type_id = "ggit_rebase_operation_type_get_type ()")]
    public enum RebaseOperationType {
        PICK,
        REWORD,
        EDIT,
        SQUASH,
        FIXUP,
        EXEC
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_REF_", type_id = "ggit_ref_type_get_type ()")]
    public enum RefType {
        INVALID,
        OID,
        SYMBOLIC,
        LISTALL
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_REMOTE_COMPLETION_", type_id = "ggit_remote_completion_type_get_type ()")]
    public enum RemoteCompletionType {
        DOWNLOAD,
        INDEXING,
        ERROR
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_REMOTE_DOWNLOAD_TAGS_", type_id = "ggit_remote_download_tags_type_get_type ()")]
    public enum RemoteDownloadTagsType {
        UNSPECIFIED,
        AUTO,
        NONE,
        ALL
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_RESET_", type_id = "ggit_reset_type_get_type ()")]
    public enum ResetType {
        SOFT,
        MIXED,
        HARD
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_SORT_", type_id = "ggit_sort_mode_get_type ()")]
    [Flags]
    public enum SortMode {
        NONE,
        TOPOLOGICAL,
        TIME,
        REVERSE
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_STASH_", type_id = "ggit_stash_flags_get_type ()")]
    [Flags]
    public enum StashFlags {
        DEFAULT,
        KEEP_INDEX,
        INCLUDE_UNTRACKED,
        INCLUDE_IGNORED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_STATUS_", type_id = "ggit_status_flags_get_type ()")]
    [Flags]
    public enum StatusFlags {
        CURRENT,
        INDEX_NEW,
        INDEX_MODIFIED,
        INDEX_DELETED,
        INDEX_RENAMED,
        INDEX_TYPECHANGE,
        WORKING_TREE_NEW,
        WORKING_TREE_MODIFIED,
        WORKING_TREE_DELETED,
        WORKING_TREE_TYPECHANGE,
        IGNORED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_STATUS_OPTION_", type_id = "ggit_status_option_get_type ()")]
    [Flags]
    public enum StatusOption {
        INCLUDE_UNTRACKED,
        INCLUDE_IGNORED,
        INCLUDE_UNMODIFIED,
        EXCLUDE_SUBMODULES,
        RECURSE_UNTRACKED_DIRS,
        DISABLE_PATHSPEC_MATCH,
        RECURSE_IGNORED_DIRS,
        RENAMES_HEAD_TO_INDEX,
        RENAMES_INDEX_TO_WORKDIR,
        SORT_CASE_SENSITIVELY,
        SORT_CASE_INSENSITIVELY,
        DEFAULT
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_STATUS_SHOW_", type_id = "ggit_status_show_get_type ()")]
    public enum StatusShow {
        INDEX_AND_WORKDIR,
        INDEX_ONLY,
        WORKDIR_ONLY
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_SUBMODULE_IGNORE_", type_id = "ggit_submodule_ignore_get_type ()")]
    public enum SubmoduleIgnore {
        UNSPECIFIED,
        NONE,
        UNTRACKED,
        DIRTY,
        ALL
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_SUBMODULE_RECURSE_", type_id = "ggit_submodule_recurse_get_type ()")]
    public enum SubmoduleRecurse {
        NO,
        YES,
        ONDEMAND
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_SUBMODULE_STATUS_", type_id = "ggit_submodule_status_get_type ()")]
    [Flags]
    public enum SubmoduleStatus {
        IN_HEAD,
        IN_INDEX,
        IN_CONFIG,
        IN_WD,
        INDEX_ADDED,
        INDEX_DELETED,
        INDEX_MODIFIED,
        WD_UNINITIALIZED,
        WD_ADDED,
        WD_DELETED,
        WD_MODIFIED,
        WD_INDEX_MODIFIED,
        WD_WD_MODIFIED,
        WD_UNTRACKED
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_SUBMODULE_UPDATE_", type_id = "ggit_submodule_update_get_type ()")]
    public enum SubmoduleUpdate {
        CHECKOUT,
        REBASE,
        MERGE,
        NONE,
        DEFAULT
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_TREE_WALK_MODE_", type_id = "ggit_tree_walk_mode_get_type ()")]
    public enum TreeWalkMode {
        PRE,
        POST
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", cprefix = "GGIT_ERROR_")]
    public errordomain Error {
        GIT_ERROR,
        NOTFOUND,
        EXISTS,
        AMBIGUOUS,
        BUFS,
        PASSTHROUGH,
        ITEROVER;
        public static GLib.Quark quark ();
    }
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 1.9)]
    public delegate int ConfigCallback (Ggit.ConfigEntry entry);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int ConfigMatchCallback (GLib.MatchInfo match_info, string value);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 4.9)]
    public delegate int CredAcquireCallback (string url, string? username_from_url, uint allowed_types, owned Ggit.Cred cred);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int DiffBinaryCallback (Ggit.DiffDelta delta, Ggit.DiffBinary binary);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int DiffFileCallback (Ggit.DiffDelta delta, float progress);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int DiffHunkCallback (Ggit.DiffDelta delta, Ggit.DiffHunk hunk);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 3.9)]
    public delegate int DiffLineCallback (Ggit.DiffDelta delta, Ggit.DiffHunk hunk, Ggit.DiffLine line);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 4.9)]
    public delegate int DiffSimilarityMetricBufferSignatureCallback (Ggit.DiffFile file, string buf, size_t buflen, void* @out);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 3.9)]
    public delegate int DiffSimilarityMetricFileSignatureCallback (Ggit.DiffFile file, string fullpath, void* @out);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 1.9)]
    public delegate void DiffSimilarityMetricFreeSignatureCallback (void* signature);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 3.9)]
    public delegate int DiffSimilarityMetricSimilarityCallback (int score, void* signature_a, void* signature_b);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int NoteCallback (Ggit.OId blob_id, Ggit.OId annotated_object_id);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 1.9)]
    public delegate int ReferencesCallback (owned Ggit.Ref reference);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 1.9)]
    public delegate int ReferencesNameCallback (string name);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 4.9)]
    public delegate int RemoteListCallback (string name, Ggit.OId oid, Ggit.OId loid, bool local);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 3.9)]
    public delegate int StashCallback (size_t index, string message, Ggit.OId stash_oid);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int StatusCallback (string path, Ggit.StatusFlags status_flags);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int SubmoduleCallback (Ggit.Submodule submodule, string name);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int TagCallback (string name, Ggit.OId tag_oid);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 1.9)]
    public delegate int TransferProgressCallback (Ggit.TransferProgress stats);
    [CCode (cheader_filename = "libgit2-glib/ggit.h", instance_pos = 2.9)]
    public delegate int TreeWalkCallback (string root, Ggit.TreeEntry entry);
    [CCode (cheader_filename = "libgit2-glib/ggit.h")]
    public static Ggit.FeatureFlags get_features ();
    [CCode (cheader_filename = "libgit2-glib/ggit.h")]
    public static void init ();
    [CCode (cheader_filename = "libgit2-glib/ggit.h")]
    public static string message_prettify (string message, bool strip_comments, char comment_char);
}
